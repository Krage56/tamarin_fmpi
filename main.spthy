theory ISO
begin

builtins: signing, diffie-hellman

rule Client_Step_1:
let
    pk_C = pk(~pr_C)
    g_x = 'g'^(~x)

in 
    [
        Fr(~pr_C),
        Fr(~x)
    ]
    --[
        Send_1($Client, $Server, <pk_C, g_x>)
    ]->
    [
        Out(pk_C, g_x),
        !Client_Step_1(~pr_C, pk_C, ~x, g_x)
    ]


rule Server_Step_1:
let
    pk_S = pk(~pr_S)
    g_y = 'g'^(~y)
    server_key = g_x^(~y)
    serv_mess = <g_x, g_y, pk_C>
    serv_mess_sign = sign(serv_mess, ~pr_S)
in
    [
        Fr(~pr_S),
        Fr(~y),
        In(pk_C, g_x)
    ]
    --[
        Receive_1($Server, $Client, <pk_C, g_x>),
        Send_2($Server, $Client, <pk_S, g_y, serv_mess_sign>)
    ]->
    [
        !Serv_Step_1(~pr_S, pk_S, ~y, g_y, g_x, server_key),
        Out(<pk_S, g_y, serv_mess_sign>)
    ]

rule Client_Step_2:
let
    serv_mess = <g_x, g_y, pk_C>
    clnt_mess = <g_y, g_x, pk_S>
    clnt_mess_sign = sign(clnt_mess, ~pr_C)
    client_key = g_y^(~x)
in
    [
        !Client_Step_1(~pr_C, pk_C, ~x, g_x),
        In(<pk_S, g_y, serv_mess_sign>),
    ]
    --[
        Eq(verify(serv_mess_sign, serv_mess, pk_S), true),
        Receive_2($Client, $Server, <pk_S, g_y, serv_mess_sign>),
        Send_3($Client, $Server, clnt_mess_sign),
        Client_Finished($Client, client_key)
    ]->
    [
        Out(clnt_mess_sign),
        !Client_Step_2(client_key, pk_S, g_y)
    ]

rule Server_Step_2:
let
    clnt_mess = <g_y, g_x, pk_S>
in 
    [
        !Serv_Step_1(~pr_S, pk_S, ~y, g_y, g_x, server_key),
        In(clnt_mess_sign)
    ]
    --[
        Eq(verify(clnt_mess_sign, clnt_mess, pk_C), true),
        Receive_3($Server, $Client, clnt_mess_sign),
        Server_Finished($Server, server_key)
    ]->
    [
        !Serv_Step_2(pk_C)
    ]
